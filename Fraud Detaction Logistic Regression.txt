import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ---------------- DATA ----------------
data = {
    "amount":      [500, 1200, 3000, 8000, 200, 15000, 400, 20000, 100, 25000],
    "frequency":   [1,2,3,4,1,6,1,7,1,8],
    "location_risk":[0,0,1,1,0,1,0,1,0,1],
    "fraud":       [0,0,0,1,0,1,0,1,0,1]
}

df = pd.DataFrame(data)

# ---------------- FUNCTIONS ----------------
def sigmoid(z):
    return 1 / (1 + np.exp(-z))

def log_loss(y_true, y_pred):
    y_pred = np.clip(y_pred, 1e-10, 1 - 1e-10)
    return -np.mean(y_true*np.log(y_pred) + (1-y_true)*np.log(1-y_pred))

def standardize(X):
    return (X - np.mean(X)) / np.std(X)

# ---------------- FEATURES ----------------
X1 = standardize(df["amount"].values)
X2 = standardize(df["frequency"].values)
X3 = standardize(df["location_risk"].values)
Y  = df["fraud"].values

# ---------------- MODEL INIT ----------------
m1 = m2 = m3 = b = 0.0
lr = 0.1
epochs = 1500
n = len(Y)

loss_history = []

# ---------------- TRAINING ----------------
for epoch in range(epochs):
    z = m1*X1 + m2*X2 + m3*X3 + b
    y_pred = sigmoid(z)

    loss = log_loss(Y, y_pred)
    loss_history.append(loss)

    dm1 = (1/n) * np.sum(X1 * (y_pred - Y))
    dm2 = (1/n) * np.sum(X2 * (y_pred - Y))
    dm3 = (1/n) * np.sum(X3 * (y_pred - Y))
    db  = (1/n) * np.sum(y_pred - Y)

    m1 -= lr * dm1
    m2 -= lr * dm2
    m3 -= lr * dm3
    b  -= lr * db

    if epoch % 200 == 0:
        print(f"Epoch {epoch} | Log Loss: {loss:.4f}")

# ---------------- LOSS CURVE ----------------
plt.plot(loss_history)
plt.xlabel("Epochs")
plt.ylabel("Log Loss")
plt.title("Fraud Detection Training Curve")
plt.grid(True)
plt.show()

# ---------------- PREDICTION ----------------
z = m1*X1 + m2*X2 + m3*X3 + b
probabilities = sigmoid(z)

threshold = 0.6
predicted_class = (probabilities >= threshold).astype(int)

# ---------------- CONFUSION MATRIX ----------------
TP = TN = FP = FN = 0
for actual, pred in zip(Y, predicted_class):
    if actual == 1 and pred == 1: TP += 1
    elif actual == 0 and pred == 0: TN += 1
    elif actual == 0 and pred == 1: FP += 1
    elif actual == 1 and pred == 0: FN += 1

# ---------------- METRICS ----------------
accuracy  = (TP + TN) / (TP + TN + FP + FN)
precision = TP / (TP + FP)
recall    = TP / (TP + FN)
fpr       = FP / (FP + TN)

print("\nConfusion Matrix")
print(f"TN:{TN} FP:{FP}")
print(f"FN:{FN} TP:{TP}")

print("\nMetrics")
print("Accuracy :", accuracy)
print("Precision:", precision)
print("Recall   :", recall)
print("FPR      :", fpr)
