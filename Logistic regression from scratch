import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# -----------------------------
# 1. Dataset
# -----------------------------
data = {
    "study_hours": [2,3,4,5,6,7,8,9,10],
    "sleep_hours": [4,5,6,7,8,8,9,9,10],
    "attendance":  [50,60,70,75,80,85,90,95,98],
    "pass_exam":   [0,0,0,0,1,1,1,1,1]
}

df = pd.DataFrame(data)
print("Dataset:\n", df)
print("="*80)

# -----------------------------
# 2. Helper Functions
# -----------------------------
def sigmoid(z):
    return 1 / (1 + np.exp(-z))

def log_loss(y_true, y_pred):
    y_pred = np.clip(y_pred, 1e-10, 1 - 1e-10)
    return -np.mean(y_true*np.log(y_pred) + (1-y_true)*np.log(1-y_pred))

# -----------------------------
# 3. Feature & Target Split
# -----------------------------
X1 = df["study_hours"].values
X2 = df["sleep_hours"].values
X3 = df["attendance"].values
Y  = df["pass_exam"].values

n = len(Y)

# -----------------------------
# 4. Model Initialization
# -----------------------------
m1 = m2 = m3 = b = 0.0
lr = 0.0001
epochs = 1000

loss_history = []

# -----------------------------
# 5. Training Loop
# -----------------------------
for epoch in range(epochs):
    z = m1*X1 + m2*X2 + m3*X3 + b
    y_pred = sigmoid(z)

    loss = log_loss(Y, y_pred)
    loss_history.append(loss)

    dm1 = (1/n) * np.sum(X1 * (y_pred - Y))
    dm2 = (1/n) * np.sum(X2 * (y_pred - Y))
    dm3 = (1/n) * np.sum(X3 * (y_pred - Y))
    db  = (1/n) * np.sum(y_pred - Y)

    m1 -= lr * dm1
    m2 -= lr * dm2
    m3 -= lr * dm3
    b  -= lr * db

    if epoch % 100 == 0:
        print(f"Epoch {epoch} | Log Loss: {loss:.4f}")

print("="*80)
print(f"Model Parameters:\nm1={m1:.4f}, m2={m2:.4f}, m3={m3:.4f}, b={b:.4f}")
print("="*80)

# -----------------------------
# 6. Loss Visualization
# -----------------------------
plt.plot(loss_history, color="green")
plt.xlabel("Epochs")
plt.ylabel("Log Loss")
plt.title("Training Loss Curve")
plt.grid(True)
plt.show()

# -----------------------------
# 7. Predictions
# -----------------------------
z = m1*X1 + m2*X2 + m3*X3 + b
probabilities = sigmoid(z)

threshold = 0.6
predicted_class = (probabilities >= threshold).astype(int)

print("Predictions:")
for p in probabilities:
    label = 1 if p >= threshold else 0
    print(f"Probability: {p:.4f} â†’ Class {label}")

print("="*80)

# -----------------------------
# 8. Confusion Matrix
# -----------------------------
TP = TN = FP = FN = 0

for actual, predicted in zip(Y, predicted_class):
    if actual == 1 and predicted == 1: TP += 1
    elif actual == 0 and predicted == 0: TN += 1
    elif actual == 0 and predicted == 1: FP += 1
    elif actual == 1 and predicted == 0: FN += 1

print("Confusion Matrix")
print(f"TN:{TN}  FP:{FP}")
print(f"FN:{FN}  TP:{TP}")
print("="*80)

# -----------------------------
# 9. Metrics
# -----------------------------
accuracy  = (TP + TN) / (TP + TN + FP + FN)
precision = TP / (TP + FP) if (TP + FP) != 0 else 0
recall    = TP / (TP + FN) if (TP + FN) != 0 else 0
fpr       = FP / (FP + TN) if (FP + TN) != 0 else 0

print(f"Accuracy : {accuracy:.2f}")
print(f"Precision: {precision:.2f}")
print(f"Recall   : {recall:.2f}")
print(f"FPR      : {fpr:.2f}")
